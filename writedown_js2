<<nodeJS>>
크롬 V8 자바스크립트 엔진으로 빌드 된 자바스크립트 런타임
    브라우저 밖에서 돌아가는 자바스크립트 
    Ryan은 자바스크립트를 브라우저에서 분리하여 nodeJS를 만듦
    *런타임(runtime) : 프로그램이 실행되고 있을 때 존재하는 곳, 프로그래밍 언어가 구동되는 환경
    (Javascipt는 web browser에서 작동하는 JavaScript가 있고 Node.js에서 구동되는 JavaScript가 있다)


<<npm>>
자바스크립트 언어를 위한 패키지 매니저
nodeJS와 상호작용을 할 수 있게 해줌 (yarn과 같은 기능)
대부분 npm 명령어 사용 아주 가끔 node 명령어
유명한 사람들이 만든 패키지들을 다운받고 사용할 수 있음.
ex) express 패키지 - 한달에 7000만명 다운로드
    npm 덕분에 npm install express로 사용가능

<<json>>
프로그래머가 파일에 정보를 저장하기 위해 만든 방식 중 하나
파일에 정보를 입력하는 방식, { key : value }
nodeJS인 경우 파일이름 = package.json이어야만 함.

<<start>>
폴더생성 - git init - git repository - git remote add - npm init 

<<package.json>>
<scripts>
"scripts": {
    "start": "node index.js"
}
Tml > npm run start
    -> node index.js가 실행됨
나중에는 서버를 시작하는 script, CSS를 압축하는 script, 웹사이트를 빌드하고 서버에 배포하는 script등을 만듦
*package.json이 있는 폴더 내에서 terminal명령어 실행시켜야 함.
*babel - "dev": babel-node index.js -> babelnode로 index.js 실행
    ex) const express = require("express"); -> import express from "express";
        Tml > npm run dev
        -> 뭔가 바뀌면 항상 저장하고 계속 실행시켜줘야함 -> nodemon사용
*nodemon - 파일이 수정되는 걸 감시해주는 패키지, 수정되면 알아서 재시작
            "nodemon --exec babel-node index.js"
            index.js를 수정하고 저장하면 알아서 서버를 재시작

<<npm>>
<npm install> (npm 웹사이트에 있는 그대로 복사 붙여넣기!)
Tml > npm i(nstall) express
package-lock.json파일과 node_modules폴더 자동 생성됨
package-lock.json - 패키지들을 안전하게 관리
node_modules - npm으로 설치한 모든 패키지가 저장되어 있음
    <express>
    node_modules > express > lib > package.json 
        "dependencies" : {}- express가 작동되려면 필요한 패키지들
            npm install express시 같이 다운받아짐
npm은 package.json의 dependencies를 보고 그 안에 있는 모듈들을 알아서 설치함
-> package.json이 중요한 이유!
<dependencies>
    프로젝트를 실행하기 위해 필요(가솔린)
<devDependencies>
    개발자에게 필요한 dependencies(운전을 잘하기 위한 음악)

<<babel>>
babel - JavaScript compiler, 작성한 최신 자바스크립트를 컴파일
nodeJS가 이해하지못하는 최신 JavaScript가 있음
    선택지 1. nodeJS가 이해하는 자바스크립트만 사용
    선택지 2. babel을 사용!
babel이 알아서 babel.config.json이라는 파일의 내용을 들여다 봄

<preset> - babel을 위한 거대한 플러그인
    preset-env : smart preset, 최신 자바스크립트 구문 사용가능

<express>
정의 :웹 및 모바일 애플리케이션을 위한 일련의 강력한 기능을 제공하는 간결하고 유연한 Node.js 프레임워크
사용 :import express from "express"; node_modules의 express에서 가져옴
        const app = express(); express로 application(server)생성

<server>
    항상 켜져있는 컴퓨터 같은 것, 인터넷에 연결 돼 있음
    request를 항상 listening함.
        callback : 서버가 시작될 때 작동하는 함수
        callback전에 어떤 port를 listening할지 얘기해 줘야 함
    보통 서버를 시작했다면 localhost:portNum를 통해서 접속할 수 있음

<Cannot GET />
    / : 서버의 root, 혹은 첫 페이지(home)
    GET : HTTP method, 페이지 갖다줘, request중 하나
        *http: 우리 혹은 서버가 서버와 소통하는 방법
        *http request : 웹사이트에 접속하고 서버에 정보를 보내는 방법
        *request : 유저가 뭔가를 요청하거나, 보내거나, 네게 무슨 행동을 하는 것

app.get("/", callback) : 누군가 root page(/)로 get request를 보낸다면 서버는 callback함수를 작동
                        'cannot GET /' error 해결
*사용자가 /login page같은 page를 원할 때 브라우저가 get request를 보냄

<handleHome>
const handleHome = (req, res) => console.log("asdf");
이 req와 res는 express로 부터 받은 것 따라서 get request를 받으면 express는 
handleHome({request받은 것}, {respond할 것})을 넣어줌 

<request>
브라우저가 보내는 요청
request object는 파일, search query, username, password를 포함 할 때도 있다

<response>
request를 받으면 response return해야 함
res.end();로 response 종료
res.send("");로 페이지에 "" print ""안에는 html,json도 포함가능

<middleware>
request와 response사이에 존재, 모든  middleware는 handler
handler = controller
controller는 req, res말고 next라는 argument를 가지고 있다.
middleware는 next();를 포함하는 controller

<next();> - 다음 함수를 호출

<app.use(globalMiddleware);> : global middleware를 생성
모든 route에서 이 globalMiddleware를 가짐
* express는 위에서 아래로 순서대로 실행하기 때문에 순서 중요 
ex) privateMiddleware
const privateMiddleware = (req, res, next) => {
    const url = req.url;
    if(url === "/protected"){
        return res.send("<h1>Not Allowed</h1>");
    }
    console.log("Allowed, you may continue.");
    next();
};

<Setup Recap>
package.json = node.js  관련정보를 넣은 text
    npm이 어떤 행동을 할 수 있게 해주는 것들이 있음
        "scripts": { "something": "" } - Tml : npm run something(aliasing)
    "dependecies": { "express": "^4.17.1"} - node_modules에 자동으로 추가
    "devDependencies": { } - node_modules로 가는 것 동일, 차이점 : 개발자가 개발할 때 필요한 것들
        ex) nodemon - 파일을 보고 있다가 변화가 생기면 command를 재시작
        ex) @babel - server.js를 node가 아닌 babel-node로 돌림 -> 최신 언어 사용가능
                babel.config.json파일을 만들어 babel에 추가하고싶은 plugin(preset)을 추가

<Server Recap>
Server : 항상 켜져있고 인터넷에 연결 돼 있으면서 request를 listening하고 있는 컴퓨터
request : 우리가 서버에 요청하는 것(브라우저를 통해 웹사이트와 상호작용하는 것)
    import express from "node_modules/express";
    const app = express(); express application을 사용할 수 있게 변수로 설정
port : 서버의 창문, request를 보내는 곳
    app.listen(4000, handleListening); : 창문(port)을 여는 곳
4000 port : backend 관습, 거의 비어있음
cannot get / : server가 브라우저의 request를 listening하고 있는데 대답해 줄 사람이 없음
http method : post, delete, get
    ex) get : 사용자가 요청을 하면 서버가 보내줌 우리가 가는 것이 아님
            express.js에서 하는 방법은 app.get을 사용
            argument : req, res, handdler

<Controller Recap>
모든 controller는 req와 res가 있다. (express로부터 주어짐, arg 순서 중요)
respond는 여러 method가 있다. ex)res.send(), res.end(), res.cookies(), res.json()
    res.end(); : finish connection
    res.send(); : text,html,json을 보낼 수 있음(화면에 띄울 수 있음)
request도 여러 method ex)req.ip(), req.cookies(), req.secure()
    req.method(); : get, post, put등의 http method 정보를 줌
    req.path(); : url

<morgan> : middleware를 return함
기존 middleware보다 정교함, next()를 포함함
    "dev" : method, path, status code, respond time
    "combined" : time, method, http version, status code, browser, os..
    "tiny"
사용 : import logger from "morgan";
    app.use(logger("dev"));

// const loggermid = (req, res, next) => {
//     console.log(`METHOD ${req.method} ${req.path}`);
//     next();
// };
// app.use(loggermid);
// const home = (req, res) => {
//     return res.send("hello");
// };
// app.get("/", home);


<<router>> - 컨트롤러와 URL의 관리를 쉽게 해줌(mini-application)
작업중인 주제를 기반으로 URL을 그룹화함
    글로벌라우터, 유저라우터, 비디오라우터

*import 하기전엔 export해야함
    default export로 변수를 export
    import한 변수는 export한 것을 불러왔기 때문에 똑같은 이름으로 안써도 무방
    반드시 하나만 default export할 수 있음

*라우터와 컨트롤러를 섞어서 쓰는것은 좋지않음
    컨트롤러는 함수, 라우터는 그것을 이용하는 입장이기 때문

*default로 export하면 이름을 바꿀 수 있었지만
 export const로 하면 실제 이름을 그대로 써야함 (오브젝트를 그대로 들고 옴)

 <:id>
 parameter - url안에 변수를 바꿔줄 수 있음
 모든 영상마다 매번 라우터를 만드는 것을 방지
 ex) /videos/123142/edit - express는 :id에 123142를 넣음
 사용 : req.params

<정규표현식> - express에선 정규표현식 사용가능
/ab*cd - abasdfsfacd, abrandomcd, abcd 
/ab+cd - abbbcd, abbbbbbbbcd
/ab?cd - b가 옵션
/ab(cd)?e - (cd)가 옵션
/(nico\w+)/g - nico로 시작하는 단어들
/(\d+)/g - 숫자만
    *JavaScript는 \ 두번

*템플릿 : 뷰 엔진으로 표시하는 웹페이지

<<pug>> - 템플릿 엔진
굉장히 편리함, html에서 <>을 생략가능(깔끔한 html), html에 자바스크립트를 포함가능
<최대장점> : partials를 이용하여 반복할 필요가 없음
<설정방법> : npm install pug -> app.set("view engine", "pug")
    :(Express에게 html helper(view engine)로 pug를 쓰겠다고 말함)
    views폴더안에 something.pug로 파일생성(express는 views폴더 안의 view폴더를 봄)
<작성방법>
    모든 건 소문자로 작성, 속성이 있으면 괄호안에 작성
    모든 건 부모속성보다 안쪽에 있어야 함(tab)
        #{Javascript code}으로 변수를 사용하거나 pug에서 자바스크립트를 사용 가능
<적용방법> : (pug에게 파일을 보내면 pug가 렌더링해서 normal html로 변환함)
    : res.render("something") #something은 view파일
<partials>
    footer example) view/partials/footer.pug 생성 -> footer내용 작성 
    -> include partials/footer.pug
<상속>
    html의 base를 만들 수 있음
    base.pug에 반복되는 html을 넣고 반복할 pug에 extends base.pug
    override하려면 block을 사용
    block : 내용을 넣을 수 있는 템플릿의 창, 부모 pug에 block st로 작성
        content block에 무언가 넣으려면 자식 pug에 block st \n html(st는 서로 이름 같아야 함)
<변수>
    #{variable}로 변수 줄 수 있음
    변수 선언은 rendering 하는 곳에서 res.render("pugfile", {변수})
    =variable으로도 변수를 줄 수 있음
    class, href, id..등은 `${}`을 사용하여야 함
<conditional>
    만약 fakeUser가 들어왔을 때 logout link만 보이도록 하려면?
    if fakeUser.loggedIn, else if fakeUser.loggedIn, else
<iteration>
    만약 array를 가져온다면 변수로 each variable in variables로 쓸 수 있음
        else도 쓸 수 있음
    *mixin : data를 받을 수 있는 partial
        작성: mixin video(mixin가 받을 data)
                반복될 문장들
        적용: include pugfile 
            +video(each문의 element)
        어떤 페이지에서도 reuse가능
<ternary operator>
#{video.views == 1 ? "view" : "views" }

*&rarr; : 오른쪽 화살표

*cwd = current working directory, process.cwd() = return 프로세스 현재 작업 dir
*현재 server를 process하는 것은 package.json(node.js를 시동), 그렇기때문에 process.cwd는 package.json이 있는 dir
*app.set("views", process.cwd() + "/directory/views") 로 임의로 views폴더 경로 설정 가능

<<MVP style>>
html을 예쁘게 만들어 줌
사용 : (in head)link(rel="stylesheet" href="https://unpkg.com/mvp.css")

* ES6 문법
const id = req.params.id;
=> const { id } = req.params;
(array: array) 
=> (array) 

<<Post>> : backend로 보내는 방법
form(method="POST")
cf) get을 사용하는 form 
    form(action="/save-changes", method="GET")
    구글에서 뭔가 검색할 때 검색어가 주소창에 포함되어 있음
*videoRouter.get("url", getController), videoRouter.post("url", postController)
=>videoRouter.route("url").get(getController).post(postController)
*express.urlencoded : post controller가 form의 body를 이해할 수 있도록 하는 middleware
    app.use(express.urlencoded({ extended: true }));
    express application이 form의 value들을 이해할 수 있도록 하고 쓸 수 있는
    자바스크립트 형식으로 변형시켜 줌

<<DataBase>>
<mongoDB>
document-based(json-like document) : object로 생각 함
document를 검색할 수 있고, 만들 수 있고, 삭제할 수도 있고, 수정, 업데이트 가능
데이터베이스를 클라우드에 배치하고, 모니터링가능


<<mongoose>> 자바스크립트에서 mongodb상호작용, nodeJS와 mongoDB를 이어주는 다리역할
<install>
>>npm i mongoose
db.js에 import mongoose from "mongoose";
mongoose.connect("url/your database name");
Event)  *mongoose.connection.on("error", function) : 여러번 발생 가능
        *mongoose.connection.once("open", function2) : 단 한번만 실행
<schema>
mongoose에게 데이터가 어떻게 생겼는지 알려줘야 함(model을 만드는 이유)
    shape = schema
    const videoSchema = new mongoose.Schema({
        title: {type: String, required: true},
        createdAt: Date,
    })
    const Video = mongoose.model("Video", videoSchema);
    export default Video; 그리고 server.js에서 import
<database loading>
Video.find({search terms},callback)
    search terms가 비어있으면 모든 형식을 찾는다는 것을 뜻함
data가 loading된 후에 진행하여야 하므로 기다려야 함.
그 방법에는 callback과 promise가 있다.
    callback : 무언가 발생하고 난 다음 호출되는 function, err와 docs라는 signature를 가짐
    promise : const home = async(req,res){ const videos = await Video.find({});}
        error-> try{}catch{}, 장점 : 보다 직관적임
        *await : database를 기다림
<post>
const video = new Video({}) //models에서 Video schema를 import
or await Video.create({}) - save()안해도 됨
만약 schema에 반하는 형식으로 post된다면 mongoose가 형변환 시키거나 제외시켜버림
video.save()로 database에 저장, promise가 내장돼있기 때문에 async와 await로 기다려야함
try{}catch{}문으로 에러검출

<CRUD>
Create, Read, Update, Delete

<return & render>
함수에서 render가 여러번 있으면 안됨
return : 함수를 종료시켜주는 기능, 실수 방지 가능