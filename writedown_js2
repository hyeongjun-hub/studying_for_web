<<nodeJS>>
크롬 V8 자바스크립트 엔진으로 빌드 된 자바스크립트 런타임
    브라우저 밖에서 돌아가는 자바스크립트 
    Ryan은 자바스크립트를 브라우저에서 분리하여 nodeJS를 만듦

<<npm>>
자바스크립트 언어를 위한 패키지 매니저
nodeJS와 상호작용을 할 수 있게 해줌 (yarn과 같은 기능)
대부분 npm 명령어 사용 아주. 가끔 node 명령어
유명한 사람들이 만든 패키지들을 다운받고 사용할 수 있음.
ex) express 패키지 - 한달에 7000만명 다운로드
    npm 덕분에 npm install express로 사용가능

<<json>>
프로그래머가 파일에 정보를 저장하기 위해 만든 방식 중 하나
파일에 정보를 입력하는 방식, { key : value }
nodeJS인 경우 파일이름 = package.json이어야만 함.

<<start>>
폴더생성 - git init - git repository - git remote add - npm init 

<<package.json>>

<scripts>
"scripts": {
    "start": "node index.js"
}
Tml > npm run start
    -> node index.js가 실행됨
나중에는 서버를 시작하는 script, CSS를 압축하는 script, 웹사이트를 빌드하고 서버에 배포하는 script등을 만듦
*package.json이 있는 폴더 내에서 terminal명령어 실행시켜야 함.
*babel - "dev": babel-node index.js -> babelnode로 index.js 실행
    ex) const express = require("express"); -> import express from "express";
        Tml > npm run dev
        -> 뭔가 바뀌면 항상 저장하고 계속 실행시켜줘야함 -> nodemon사용
*nodemon - 파일이 수정되는 걸 감시해주는 패키지, 수정되면 알아서 재시작
            "nodemon --exec babel-node index.js"
            index.js를 수정하고 저장하면 알아서 서버를 재시작

<<npm>>

<npm install> (npm 웹사이트에 있는 그대로 복사 붙여넣기!)
Tml > npm i(nstall) express
package-lock.json파일과 node_modules폴더 자동 생성됨
package-lock.json - 패키지들을 안전하게 관리
node_modules - npm으로 설치한 모든 패키지가 저장되어 있음
    <express>
    node_modules > express > lib > package.json 
        "dependencies" : {}- express가 작동되려면 필요한 패키지들
            npm install express시 같이 다운받아짐
npm은 package.json의 dependencies를 보고 그 안에 있는 모듈들을 알아서 설치함
-> package.json이 중요한 이유!
<dependencies>
    프로젝트를 실행하기 위해 필요(가솔린)
<devDependencies>
    개발자에게 필요한 dependencies(운전을 잘하기 위한 음악)

<<babel>>
babel - JavaScript compiler, 작성한 최신 자바스크립트를 컴파일
nodeJS가 이해하지못하는 최신 JavaScript가 있음
    선택지 1. nodeJS가 이해하는 자바스크립트만 사용
    선택지 2. babel을 사용!
babel이 알아서 babel.config.json이라는 파일의 내용을 들여다 봄

<preset> - babel을 위한 거대한 플러그인
    preset-env : smart preset, 최신 자바스크립트 구문 사용가능

<express>
    import express from "express"; node_modules의 express에서 가져옴
    const app = express(); express로 application(server)생성

<server>
    항상 켜져있는 컴퓨터 같은 것, 인터넷에 연결 돼 있음
    request를 항상 listening함.
        callback : 서버가 시작될 때 작동하는 함수
        callback전에 어떤 port를 listening할지 얘기해 줘야 함
    보통 서버를 시작했다면 localhost:portNum를 통해서 접속할 수 있음

<Cannot GET />
    / : 서버의 root, 혹은 첫 페이지(home)
    GET : HTTP method, 페이지 갖다줘, request중 하나
        *http: 우리 혹은 서버가 서버와 소통하는 방법
        *http request : 웹사이트에 접속하고 서버에 정보를 보내는 방법
        *request : 유저가 뭔가를 요청하거나, 보내거나, 네게 무슨 행동을 하는 것

app.get("/", callback) : 누군가 root page(/)로 get request를 보낸다면 서버는 callback함수를 작동
                        'cannot GET /' error 해결
*사용자가 /rogin page같은 page를 원할 때 브라우저가 get request를 보냄

<handleHome>
const handleHome = (req, res) => console.log("asdf");
이 req와 res는 express로 부터 받은 것 따라서 get request를 받으면 express는 
handleHome( {request받은 것}, {respond할 것})을 넣어줌 (express 역할)

<request>
브라우저가 보내는 요청
request object는 파일, search query, username, password를 포함 할 때도 있다

<response>
request를 받으면 response return해야 함
res.end();로 response 종료
res.send("");로 페이지에 "" print ""안에는 html,json도 포함가능

<middleware>
requenst와 response사이에 존재, 모든  middleware는 handler
handler = controller
controller는 req, res말고 next라는 argument를 가지고 있다.
middleware는 next();를 포함하는 controller

<next> - 다음 함수를 호출
